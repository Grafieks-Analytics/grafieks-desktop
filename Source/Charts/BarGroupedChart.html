<!DOCTYPE html>
<html>
    <head>
        <script src="./Data/d3DefaultConfig.js"></script>
        <script src="./Data/utils.js"></script>
        <script src="./Data/d3.v4.min.js"></script>
        <script src="./Data/d3-scale-chromatic.v1.min.js"></script>
        <link rel="stylesheet" href="Data/general.css" />
        <style type="text/css">
            body {
                padding: 0;
                margin: 0;
            }
        </style>
        <style>
            .axis .domain {
                display: none;
            }
        </style>
        <style type="text/css">
            body {
                padding: 0;
                margin: 0;
                overflow-y: hidden;
                /* overflow-x: hidden; */
            }
            #yAxisDiv {
                position: fixed;
                background: #fff;
            }
        </style>
    </head>

    <body>
        <div style="display: flex">
            <div id="yAxisDiv"></div>
            <div id="my_dataviz"></div>
        </div>
        <div id="tooltip"></div>
        <script>
            var extraHeightWorked = false;
            var redrawn = false;
            var extraHeight = 0;
            function sumAllData(originalData, currentData) {
                var allKeys = [
                    ...Object.keys(originalData),
                    ...Object.keys(currentData),
                ];

                allKeys = allKeys.filter((d) => {
                    if (d != "mainCategory") {
                        return d;
                    }
                });

                allKeys.forEach((d) => {
                    // console.log(originalData[d], currentData[d]);
                    originalData[d] =
                        (originalData[d] || 0) + (currentData[d] || 0);
                });

                // debugger;

                return originalData;
            }

            function transformData(dataValue, dateFormat) {
                var transformedDataValue = {};
                var globalKeys = [];

                dataValue[0].forEach((d, i) => {
                    var currentData = d;

                    var isKey1Date = false;
                    if (isDateFormat(d.mainCategory)) {
                        isKey1Date = true;
                    }

                    var category = d.mainCategory;
                    if (isKey1Date) {
                        category = getDateFormattedData(
                            d.mainCategory,
                            dateFormat
                        );
                    }
                    // console.log(category);
                    if (!transformedDataValue[category]) {
                        transformedDataValue[category] = {};
                    }
                    var originalData = transformedDataValue[category];

                    var allKeys = [
                        ...Object.keys(originalData),
                        ...Object.keys(currentData),
                    ];

                    allKeys = allKeys
                        .filter((d) => {
                            if (d != "mainCategory") {
                                return d;
                            }
                        })
                        .filter(getUniqueArrayValues);

                    globalKeys.push(...allKeys);

                    allKeys.forEach((d) => {
                        // console.log(originalData[d], currentData[d]);
                        originalData[d] =
                            (originalData[d] || 0) + (currentData[d] || 0);
                    });
                    transformedDataValue[category] = {
                        ...originalData,
                        mainCategory: category,
                    };

                    // console.log({ transformedDataValue });
                });

                var transformedDataValue = Object.keys(
                    transformedDataValue
                ).map((d) => transformedDataValue[d]);

                globalKeys = globalKeys.filter(getUniqueArrayValues);
                return [transformedDataValue, globalKeys];
            }

            function drawChart(data, plottingConfiguration = {}) {
                window.data = data;

                let {
                    d3colorPalette,
                    paddingInner,
                    markerShape,
                    curveType,
                    dateFormat,
                    chartType,
                    standardThresholdWidth,
                    options,
                    fontSize = defaultD3Config.fontSize,
                } = plottingConfiguration;

                var { groupBarChartColorBy } = options || {};

                if (!d3colorPalette) {
                    d3colorPalette = defaultD3Config.d3ColorPalette;
                }
                d3Colors = d3colorPalette;

                if (!paddingInner) {
                    paddingInner = defaultD3Config.defaultPaddingInner;
                }

                if (!dateFormat) {
                    dateFormat = defaultD3Config.dateFormat;
                }

                if (!chartType) {
                    chartType = defaultD3Config.chartType;
                }

                if (!standardThresholdWidth) {
                    standardThresholdWidth =
                        defaultD3Config.standardThresholdWidth;
                }

                data = transformData(data, dateFormat);

                var [data, all_keys] = data;

                let { top, right, bottom, left } = constants.chartMargins;
                if (window.innerHeight < 400) {
                    top = top / 2;
                    right = right / 2;
                    // bottom = bottom / 2;
                }
                var margin = { top, right, bottom, left };
                var width = window.innerWidth - margin.left - margin.right - 70;

                if (chartType == constants.chartType.STANDARD) {
                    width = numberOfBars(data) * standardThresholdWidth;
                }

                function numberOfBars(data) {
                    var count = 0;
                    for (var i = 0; i < data.length; i++) {
                        var innerData = data[i];
                        count += Object.keys(innerData).length - 1;
                    }
                    return count;
                }

                var height =
                    window.innerHeight -
                    margin.top -
                    margin.bottom -
                    extraHeight;

                clearChart();

                var minHeight = d3.min(data, (d) =>
                    d3.min(all_keys, (k) => d[k])
                );

                if (minHeight > 0) {
                    minHeight = 0;
                }

                var maxHeight = d3.max(data, (d) =>
                    d3.max(all_keys, (k) => d[k])
                );

                //add svg with margin !important
                //this is svg is actually group
                var svg = d3
                    .selectAll("#my_dataviz")
                    .append("svg")
                    .attr("width", width + 100)
                    .attr(
                        "height",
                        height + extraHeight + margin.top + margin.bottom
                    )
                    .append("g") //add group to leave margin for axis
                    .attr(
                        "transform",
                        "translate(" + margin.left + "," + margin.top + ")"
                    );

                const xScale0 = d3
                    .scaleBand()
                    .range([0, width])
                    .padding(paddingInner);

                // var yScale = d3
                //     .scaleLinear()
                //     .rangeRound([0, height])
                //     .domain([maxHeight, minHeight])
                //     .nice();

                const yScale = d3
                    .scaleLinear()
                    .range([height - margin.top - margin.bottom, 0]);

                var zScale = d3.scaleOrdinal().range(d3Colors);

                // const xAxis = d3.axisBottom(xScale0);
                // const yAxis = d3.axisLeft(yScale);

                yaxisTicks = height / 70;

                yScale.domain([minHeight, maxHeight]).nice();

                //add x and y axis
                var yAxis = d3.axisLeft(yScale).tickSize(0).ticks(yaxisTicks);

                d3.select("#yAxisDiv")
                    .append("svg")
                    .attr("width", "72")
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g") //add group to leave margin for axis
                    .attr(
                        "transform",
                        "translate(" + margin.left + "," + margin.top + ")"
                    )
                    .append("g")
                    .attr("class", "y-axis")
                    .call(yAxis);

                xScale0.domain(data.map((d) => d.mainCategory));

                svg.append("g")
                    .attr("class", "grid")
                    .style("stroke-width", "1")
                    .call(
                        make_y_gridlines(yScale).tickSize(-width).tickFormat("")
                    );

                svg.selectAll(".groups")
                    .data(data)
                    .enter()
                    .append("g")
                    .attr("class", "mainCategory")
                    .each(function (group_data) {
                        const bar_data = getBars(group_data),
                            x_offset = groupOffset(group_data),
                            group_keys = bar_data.map((d) => d.name);
                        xScale1 = d3
                            .scaleBand()
                            .domain(group_keys)
                            .range([0, xScale0.bandwidth() - x_offset * 2])
                            .padding(paddingInner);

                        d3.select(this)
                            .attr(
                                "transform",
                                (d) =>
                                    `translate(${
                                        xScale0(d.mainCategory) + x_offset
                                    },0)`
                            )
                            .selectAll(".bar")
                            .data(bar_data)
                            .enter()
                            .append("rect")
                            .attr("class", "bar")
                            .attr("fill", function (d) {
                                if (groupBarChartColorBy == "category") {
                                    return zScale(d.data.mainCategory);
                                }
                                if (groupBarChartColorBy == "subcategory") {
                                    return zScale(d.name);
                                }
                                return d3Colors[0];
                            })
                            .on("mouseout", function (d, i) {
                                d3.select("#tooltip").style("display", "none");
                                d3.selectAll(".bar").style("opacity", 1);
                            })
                            .on("mouseover mousemove", function (d, i) {
                                let xpos = d3.mouse(this)[0] - 20;
                                let ypos = d3.mouse(this)[1];
                                var parentElement = this.parentElement;

                                const matrix =
                                    window.getComputedStyle(
                                        parentElement
                                    ).transform;
                                const matrixValues = matrix
                                    .match(/matrix.*\((.+)\)/)[1]
                                    .split(", ");

                                xpos += +matrixValues[4] || 0;

                                d3.select("#tooltip")
                                    .style("left", xpos + "px")
                                    .style("top", ypos + "px")
                                    .style("display", "block")
                                    .html(d.name + ":" + d.value);

                                d3.selectAll(".bar").style("opacity", 0.3);
                                d3.select(this).style("opacity", 1);
                            })
                            .attr("x", (d) => xScale1(d.name))
                            .attr("y", (d) => {
                                if (d.value < 0) {
                                    return yScale(0);
                                }
                                return yScale(d.value);
                            })
                            .attr("width", xScale1.bandwidth())
                            .attr("height", (d) => {
                                var heightValue = Math.abs(
                                    yScale(0) - yScale(Math.abs(d.value))
                                );
                                if (!heightValue) {
                                    heightValue = 1;
                                }
                                return heightValue;

                                // return (
                                //     height -
                                //     margin.top -
                                //     margin.bottom -
                                //     yScale(d.value)
                                // );
                            });
                    });

                var xAxis = d3.axisBottom(xScale0);

                // Add the X Axis
                svg.append("g")
                    .attr("class", "x-axis")
                    .attr(
                        "transform",
                        `translate(0,${height - margin.top - margin.bottom})`
                    )
                    .call(xAxis);

                // Add the Y Axis
                // svg.append("g").attr("class", "y-axis").call(yAxis);

                function getBars(d) {
                    const bars = [];
                    all_keys.forEach((k) => {
                        if (d.hasOwnProperty(k)) {
                            bars.push({ name: k, value: d[k], data: d });
                        }
                    });
                    return bars;
                }

                function groupOffset(d) {
                    const groupElementsCount = all_keys.reduce(
                            (acc, k) =>
                                d.hasOwnProperty(k) ? (acc += 1) : acc,
                            0
                        ),
                        allElementsCount = all_keys.length,
                        groupWidth = xScale0.bandwidth(),
                        x_offset =
                            ((1 - groupElementsCount / allElementsCount) *
                                groupWidth) /
                            2;

                    return x_offset;
                }

                setYaxisWidth();

                var barWidth = xScale0.bandwidth();
                if (
                    chartType == constants.chartType.FIT_WIDTH &&
                    barWidth < 40
                ) {
                    setXaxisWidth();
                }

                function setStandardTickWidths() {
                    var a = document.querySelectorAll(".x-axis .tick text");

                    for (var i = 0; i < a.length; i++) {
                        var singleCharacterLength =
                            a[i].getBBox().width / a[i].innerHTML.length;
                        var numOfCharacters = Math.floor(
                            barWidth / singleCharacterLength
                        );

                        var tick = a[i];

                        var tickWidth = tick && tick.getBBox().width;
                        if (tickWidth > barWidth) {
                            // console.log("Length is long", numOfCharacters);
                            var tickValue = tick.innerHTML;
                            tickValue =
                                tickValue &&
                                tickValue.substr(0, numOfCharacters - 3) +
                                    "...";
                            // console.log(tickValue);
                            tick.innerHTML = tickValue;
                        }
                    }
                }

                function setXaxisWidth() {
                    var allYAxisTicks =
                        document.querySelectorAll(".x-axis .tick");
                    var maxWidth = 72;
                    for (var i = 0; i < allYAxisTicks.length; i++) {
                        var tick = allYAxisTicks[i];
                        var width = tick && tick.getBBox().width;
                        if (width > maxWidth) {
                            maxWidth = width;
                        }
                    }

                    extraHeightWorked = true;
                    maxWidth = maxWidth < 100 ? maxWidth : 100;
                    extraHeight = maxWidth + 2;

                    // console.log({ extraHeight });
                    d3.select(".x-axis").attr("text-anchor", "right");
                    d3.selectAll(".x-axis text")
                        .attr("transform", "rotate(-90)")
                        .attr("dy", "0.3em")
                        .attr("x", "-" + (maxWidth + 10))
                        .attr("font-size", fontSize)
                        .attr("y", "0");
                }

                allXAxisTexts = document.querySelectorAll(".x-axis text");
                var textWidth = document
                    .querySelector(".x-axis .tick text")
                    .getBBox().height;

                if (
                    chartType == constants.chartType.FIT_WIDTH &&
                    xScale0.bandwidth() < 40
                ) {
                    for (var i = 0; i < allXAxisTexts.length; i++) {
                        if (!Math.floor(data.length * 0.04)) {
                            break;
                        }

                        if (i % Math.floor(data.length * 0.04) != 0) {
                            allXAxisTexts[i].remove();
                            continue;
                        }

                        if (allXAxisTexts[i] && allXAxisTexts[i].innerHTML) {
                            var singleCharacterLength =
                                allXAxisTexts[i].getBBox().width /
                                allXAxisTexts[i].innerHTML.length;

                            var numOfCharacters =
                                extraHeight / singleCharacterLength;

                            if (
                                allXAxisTexts[i].innerHTML &&
                                allXAxisTexts[i].innerHTML.length >
                                    numOfCharacters
                            ) {
                                if (Math.floor(numOfCharacters) > 3) {
                                    allXAxisTexts[i].innerHTML =
                                        (allXAxisTexts[i].innerHTML &&
                                            allXAxisTexts[i].innerHTML.substr(
                                                0,
                                                numOfCharacters - 3
                                            )) + "...";
                                } else {
                                    allXAxisTexts[i].innerHTML =
                                        (allXAxisTexts[i].innerHTML &&
                                            allXAxisTexts[i].innerHTML.substr(
                                                0,
                                                2
                                            )) + "...";
                                }
                            }
                        }

                        if (i == 0 && barWidth < textWidth * 0.5) {
                            allXAxisTexts[i].setAttribute("dy", "1em");
                            continue;
                        }
                        if (barWidth < textWidth * 0.5) {
                            allXAxisTexts[i].setAttribute("dy", "0.8em");
                        }

                        // console.log("Axis Data", allXAxisTexts[i]);
                        // if (allXAxisTexts[i] && allXAxisTexts[i].innerHTML) {
                        //     var singleCharacterLength =
                        //         allXAxisTexts[i].getBBox().width /
                        //         allXAxisTexts[i].innerHTML.length;
                        //     var numOfCharacters =
                        //         extraHeight / singleCharacterLength;

                        // }
                    }
                }

                if (extraHeightWorked && !redrawn) {
                    extraHeightWorked = false;
                    redrawn = true;
                    drawChart(window.data, plottingConfiguration);
                    var mainChart = document.querySelector("#my_dataviz svg");
                    var heightValue = mainChart.getAttribute("height");
                    heightValue = +heightValue + extraHeight;
                    mainChart.setAttribute("height", heightValue);
                }

                if (extraHeightWorked && redrawn) {
                    extraHeightWorked = false;
                    redrawn = false;
                }

                function setYaxisWidth() {
                    var allYAxisTicks =
                        document.querySelectorAll(".y-axis .tick");
                    var maxWidth = 72;
                    for (var i = 0; i < allYAxisTicks.length; i++) {
                        var tick = allYAxisTicks[i];
                        var width = tick && tick.getBBox().width + 25;
                        if (width > maxWidth) {
                            maxWidth = width;
                        }
                    }

                    var yAxisDiv = document.querySelector("#yAxisDiv svg");

                    yAxisDiv.setAttribute("width", maxWidth);
                    yAxisDiv.setAttribute(
                        "transform",
                        "translate(" + (maxWidth - margin.left) + "," + 0 + ")"
                    );
                }

                function make_x_gridlines(x) {
                    return d3.axisBottom(x).ticks(8);
                }
                function make_y_gridlines(y) {
                    return d3.axisLeft(y).ticks(yaxisTicks);
                }

                function getDateFormattedData(dateValue, dateFormat) {
                    return d3.timeFormat(dateFormat)(new Date(dateValue));
                }
            }

            var data = [
                [
                    {
                        Bookcases: 8016,
                        Chairs: 6906,
                        Furnishings: 2398,
                        Tables: 10230,
                        mainCategory: "Furniture",
                    },
                    {
                        Appliances: 1060,
                        Art: 2756,
                        Binders: 2114,
                        Envelopes: 1134,
                        Fasteners: 160,
                        Labels: 192,
                        Paper: 1198,
                        Storage: 4638,
                        Supplies: 132,
                        mainCategory: "OfficeSupplies",
                    },
                    {
                        Accessories: 938,
                        Phones: 8372,
                        mainCategory: "Technology",
                    },
                ],
                [
                    [
                        "Bookcases",
                        "Chairs",
                        "Labels",
                        "Tables",
                        "Storage",
                        "Furnishings",
                        "Art",
                        "Phones",
                        "Binders",
                        "Appliances",
                        "Paper",
                        "Envelopes",
                        "Accessories",
                        "Fasteners",
                        "Supplies",
                    ],
                ],
            ];
            drawChart(data);
        </script>
    </body>
</html>
