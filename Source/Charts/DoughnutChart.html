<!DOCTYPE html>

<head>
    <meta charset="utf-8" />

    <!-- Load d3.js -->
    <script src="./Data/d3.v4.min.js"></script>

    <!-- Color scale -->
    <script src="./Data/d3DefaultConfig.js"></script>
    <script src="./Data/utils.js"></script>

    <script src="Data/d3-scale-chromatic.v1.min.js"></script>
    <link rel="stylesheet" href="Data/general.css" />

    <title>Pie Chart</title>
</head>
<body>
    <!-- Create a div where the graph will take place -->
    <div id="my_dataviz"></div>
    <div id="tooltip"></div>
    <div id="legend"></div>

    <script>
        var data = { a: 9, b: 20, c: 30, d: 8, e: 12, g: 45 };

        function drawChart(data, plottingConfiguration = {}) {
            let { d3colorPalette, paddingInner, legendConfig,labelConfig, innerRadius } =
                plottingConfiguration;
                  
            if (!d3colorPalette) {
                d3colorPalette = defaultD3Config.d3ColorPalette;
            }
            if (!labelConfig) {
                labelConfig = defaultD3Config.defaultlabelConfig;
            }
            
            const d3Colors = d3colorPalette;
            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 30, bottom: 70, left: 60 },
                width = window.innerWidth - margin.left - margin.right + 80,
                height = window.innerHeight - margin.top - margin.bottom - 20;

            if (!legendConfig) {
                legendConfig = { legendStatus: false };
            }

            if (!innerRadius) {
                innerRadius = defaultD3Config.innerRadius;
            }

            let { legendStatus, legendPosition } = legendConfig;
            let { labelStatus } = labelConfig;

            if (legendStatus) {
                var legendHeight =
                    document.querySelector("#legend").offsetHeight;
                var legendElement = document.querySelector("#legend");

                topPosition = "calc(50vh - " + legendHeight + "px)";
                legendElement.style.padding = "10px";

                switch (legendPosition) {
                    case "left":
                        margin.left += 100;
                        width -= 100;
                        d3.select("#legend")
                            .style("top", topPosition)
                            .style("right", "auto")
                            .style("bottom", "auto")
                            .style("left", "20px")
                            .style("display", "block");
                        break;
                    case "top":
                        margin.top += 80;
                        height -= 100;
                        d3.select("#legend")
                            .style("top", "20px")
                            .style("right", "auto")
                            .style("bottom", "auto")
                            .style("left", margin.left + "px")
                            .style("display", "flex");
                        d3.selectAll("#legend div").style("padding", "2px 4px");
                        break;
                    case "bottom":
                        height -= 80;
                        margin.bottom += 80;
                        d3.select("#legend")
                            .style("top", "auto")
                            .style("right", "auto")
                            .style("bottom", "80px")
                            .style("left", margin.left + "px")
                            .style("display", "flex");
                        break;
                    // For Right Legened
                    case "right":
                    default:
                        width -= 100;
                        d3.select("#legend")
                            .style("right", "20px")
                            .style("left", "auto")
                            .style("top", topPosition)
                            .style("bottom", "auto")
                            .style("display", "block");
                }
            }

            d3.select("#legend").html("").style("padding", "");

            if (legendStatus) {
                d3.select("#legend").html("");
                d3.select("#legend")
                    .selectAll("div")
                    .data(Object.keys(data))
                    .enter()
                    .append("div")
                    .html((d, i) => {
                        return (
                            '<div style="width: 15px; height: 15px; margin-top:2px; background: ' +
                            d3Colors[i] +
                            ';">  </div>' +
                            "<span style='margin-left: 5px; max-width: 80px'>" +
                            d +
                            "</span>"
                        );
                    })
                    .style("display", "flex")
                    .style("padding", "2px");
            }

            // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
            var radius = Math.min(width, height) / 2;

            d3.selectAll("#my_dataviz").html("");
            // append the svg object to the div called 'my_dataviz'
            var svg = d3
                .select("#my_dataviz")
                .append("svg")
                .attr("width", width )
                .attr("height", height + 80)
                .append("g")
                .attr(
                    "transform",
                    "translate(" + width / 2 + "," + (height+100) / 2 + ")"
                );

            // set the color scale
            var color = d3
                .scaleOrdinal()
                .domain(Object.keys(data))
                .range(d3Colors);
            var totalSum = arraySum(Object.values(data));


            // Compute the position of each group on the pie:
            var pie = d3
                .pie()
                .value(function (d) {
                    return d.value;
                })
                .sort(function (a, b) {
                    return d3.ascending(a.key, b.key);
                }); // This make sure that group order remains the same in the pie chart

            var data_ready = pie(d3.entries(data));

            // map to data
            var u = svg.selectAll("path").data(data_ready);

            // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
            u.enter()
                .append("path")
                .merge(u)
                // .transition()
                // .duration(1000)
                .attr(
                    "d",
                    d3.arc().innerRadius(innerRadius).outerRadius(radius)
                )
                .attr("fill", function (d) {
                    this.setAttribute("data-label-name",d.data.key);
                    this.setAttribute("data-value",d.data.value);
                    this.setAttribute('data-percentage',(d.data.value/totalSum)*100)
                
                    return color(d.data.key);
                })
                .attr("class", function (d, i) {
                    return "pie";
                })
                .attr("stroke", "white")
                .style("stroke-width", "0.2px")
                .style("opacity", 1)
                .on("mouseover mousemove", function (d, i) {
                    var x_pos = d3.mouse(this)[0] + width / 2 +15;
                    var y_pos = d3.mouse(this)[1] + height / 2 +8;

                    d3.select("#tooltip")
                        .style("left", x_pos + "px")
                        .style("top", y_pos + "px")
                        .style("display", "block")
                        // .text(d.data.key);
                        .html(function () {
                                // var textValue = d.y0 - d.y1;
                                // if (d.y1 < 0) {
                                //     textValue = d.y1 - d.y0;
                                // }

                                return (
                                    "<div class='arrowTooltip'></div>" +
                                    "<span style='color:grey;''>" +
                                    "xAxisLabel" +
                                    ":&nbsp;&nbsp;" +
                                    "</span>" +
                                    "<span style='float: right;'>" +
                                    d.data.key +
                                    "</span>" +
                                    "<br/> <br/>" +
                                    "<span style='color:grey;''>" +
                                    "yAxisLabel" +
                                    ":" +
                                    "</span>" +
                                    "<span style='float: right;margin-left: 15px;'>" +
                                    "yValue.toFixed(2)" +
                                    "</span>"
                                );
                            });

                        d3.select(".arrowTooltip").attr(
                                "style",
                                "border: solid; border-color: white transparent; border-width: 12px 6px 0 6px; content: '';left: -12px; transform: rotate(90deg)!important;bottom: 22px; position: absolute;"
                            );
                    d3.selectAll(".pie").style("opacity", 0.3);
                    d3.select(this).style("opacity", 1);
                })

                .on("mouseout", function (d, i) {
                    d3.select("#tooltip").style("display", "none");

                    d3.selectAll(".pie").style("opacity", 1);
                });

            // remove the group that is not present anymore
            u.exit().remove();

            var data_ready = pie(d3.entries(data));

            // The arc generator
            var arc = d3
                .arc()
                .innerRadius(radius * 0.5) // This is the size of the donut hole
                .outerRadius(radius * 0.8);

            // Another arc that won't be drawn. Just for labels positioning
            var outerArc = d3
                .arc()
                .innerRadius(radius * 0.9)
                .outerRadius(radius * 0.9);
            if (labelStatus) {
                // Add the polylines between chart and labels:
                svg.selectAll("allPolylines")
                    .data(data_ready)
                    .enter()
                    .append("polyline")
                    .attr("stroke", "grey")
                    .style("fill", "none")
                    .attr("stroke-width", 1)
                    .attr("points", function (d) {
                        var posA = arc.centroid(d); // line insertion in the slice
                        // var abc = posA * 2;
                        console.log(posA);
                        var posB = outerArc.centroid(d); // line break: we use the other arc generator that has been built only for that
                        var posC = outerArc.centroid(d); // Label position = almost the same as posB
                        var midangle =
                            d.startAngle + (d.endAngle - d.startAngle) / 2; // we need the angle to see if the X position will be at the extreme right or extreme left
                        posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
                        return [posA, posB, posC];
                    }); 

                // Add the polylines between chart and labels:
                svg.selectAll("allLabels")
                    .data(data_ready)
                    .enter()
                    .append("text")
                    .text(function (d) {
                        console.log(d.data.key);
                        return d.data.key;
                    })
                    .attr("transform", function (d) {
                        var pos = outerArc.centroid(d);
                        var midangle =
                            d.startAngle + (d.endAngle - d.startAngle) / 2;
                        pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                        return "translate(" + pos + ")";
                    })
                    .style("text-anchor", function (d) {
                        var midangle =
                            d.startAngle + (d.endAngle - d.startAngle) / 2;
                        return midangle < Math.PI ? "start" : "end";
                    });
            }
        }

        // Initialize the plot with the first dataset
        drawChart(data);
    </script>
</body>
