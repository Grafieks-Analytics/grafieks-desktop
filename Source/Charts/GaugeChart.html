<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=320" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <title>Gauge Chart</title>

        <script src="./Data/d3DefaultConfig.js"></script>
        <script type="text/javascript" src="./Data/d3.v3.min.js"></script>
        <script src="./Data/utils.js"></script>
        <style>
            body {
                font-family: Helvetica, Arial, sans-serif;
                margin: 32px;
                text-align: center;
            }

            #my_datavix g.arc {
                fill: steelblue;
            }

            #my_datavix g.pointer {
                fill: #e85116;
                stroke: #b64011;
            }

            #my_datavix g.label text {
                text-anchor: middle;
                font-size: 14px;
                font-weight: bold;
                fill: #666;
            }
        </style>
    </head>
    <body>
        <div id="my_dataviz"></div>
        <div class="text-center" id="x"></div>

        <script>
            var gauge = function (container, configuration) {
                var that = {};
                var config = {
                    size: 100,
                    clipWidth: window.innerWidth,
                    clipHeight: window.innerHeight,
                    ringInset: 20,
                    ringWidth: 20,

                    pointerWidth: 10,
                    pointerTailLength: 5,
                    pointerHeadLengthPercent: 0.9,

                    minValue: 0,
                    maxValue: 20,

                    minAngle: -90,
                    maxAngle: 90,

                    transitionMs: 750,

                    majorTicks: 3,
                    labelFormat: d3.format(".1s"),
                    labelInset: 10,

                    arcColorFn: d3.interpolateHsl(
                        d3.rgb("#b3de69"),
                        d3.rgb("#fccde5")
                    ),
                };
                var range = undefined;
                var r = undefined;
                var pointerHeadLength = undefined;
                var value = 0;

                var svg = undefined;
                var arc = undefined;
                var scale = undefined;
                var ticks = undefined;
                var tickData = undefined;
                var pointer = undefined;

                var donut = d3.layout.pie();

                function deg2rad(deg) {
                    return (deg * Math.PI) / 180;
                }

                function newAngle(d) {
                    var ratio = scale(d);
                    var newAngle = config.minAngle + ratio * range;
                    return newAngle;
                }

                function configure(configuration) {
                    var prop = undefined;
                    for (prop in configuration) {
                        config[prop] = configuration[prop];
                    }

                    range = config.maxAngle - config.minAngle;
                    r = config.size / 2;
                    pointerHeadLength = Math.round(
                        r * config.pointerHeadLengthPercent
                    );

                    // a linear scale that maps domain values to a percent from 0..1
                    scale = d3.scale
                        .linear()
                        .range([0, 1])
                        .domain([config.minValue, config.maxValue]);

                    ticks = scale.ticks(config.majorTicks);
                    console.log("ticks", ticks);

                    const { maxValue, redValue, yellowValue } = config;

                    var redValueData = redValue / maxValue;

                    tickData = [
                        redValue / maxValue,
                        (yellowValue - redValue) / maxValue,
                        (maxValue - yellowValue) / maxValue,
                    ];
                    var covered = 0;

                    arc = d3.svg
                        .arc()
                        .innerRadius(r - config.ringWidth - config.ringInset)
                        .outerRadius(r - config.ringInset)
                        .startAngle(function (d, i) {
                            var ratio = covered;
                            covered += d;
                            return deg2rad(config.minAngle + ratio * range);
                        })
                        .endAngle(function (d, i) {
                            return deg2rad(config.minAngle + covered * range);
                        });
                }
                that.configure = configure;

                function centerTranslation() {
                    return "translate(" + (r + 5) + "," + (r + 5) + ")";
                }

                function isRendered() {
                    return svg !== undefined;
                }
                that.isRendered = isRendered;

                function render(newValue) {
                    svg = d3
                        .select(container)
                        .append("svg:svg")
                        .attr("class", "gauge")
                        .attr("width", config.clipWidth + 20)
                        .attr("height", config.clipHeight + 20);

                    var centerTx = centerTranslation();

                    var arcs = svg
                        .append("g")
                        .attr("class", "arc")
                        .attr("transform", centerTx);

                    arcs.selectAll("path")
                        .data(tickData)
                        .enter()
                        .append("path")
                        .attr("class", function (d, i) {
                            switch (i) {
                                case 0:
                                    return "red";
                                case 1:
                                    return "yellow";
                                case 2:
                                    return "green";
                            }
                        })
                        .attr("fill", function (d, i) {
                            switch (i) {
                                case 0:
                                    return constants.redColor;
                                case 1:
                                    return constants.yellowColor;
                                case 2:
                                    return constants.greenColor;
                            }
                        })
                        .attr("d", arc);

                    var lg = svg
                        .append("g")
                        .attr("class", "label")
                        .attr("transform", centerTx);

                    const { maxValue, redValue, yellowValue } = config;

                    ticks = [ticks[0], redValue, yellowValue, maxValue];
                    console.log("ticks", ticks);

                    lg.selectAll("text")
                        .data(ticks)
                        .enter()
                        .append("text")
                        .attr("transform", function (d, i) {
                            var ratio = scale(d);
                            var newAngle = config.minAngle + ratio * range;
                            console.log(d, ratio, newAngle);
                            if (!i) {
                                this.setAttribute('x',config.labelInset - r + 60)
                                this.setAttribute('y',25)
                                // this.setAttribute('tick-position', 'start')
                                return null;
                            }
                            if(i == ticks.length - 1){
                                this.setAttribute('x',config.labelInset + r)
                                this.setAttribute('tick-position', 'end')
                                return null;
                            }
                            return (
                                "rotate(" +
                                newAngle +
                                ") translate(0," +
                                (config.labelInset - r) +
                                ")"
                            );
                        })
                        .text(config.labelFormat);

                    var endTicks = document.querySelectorAll('[tick-position]');
                    endTicks.forEach(tick=>{
                        console.log(tick);
                        if(tick.getAttribute('tick-position') == "end"){
                            var xPositon = +tick.getAttribute('x');
                            var width = tick.getBBox().width;
                            tick.setAttribute('x',xPositon - width - 60)
                            tick.setAttribute('y',25)

                        }
                    })
                        
                    var lineData = [
                        [config.pointerWidth / 2, 0],
                        [0, -pointerHeadLength],
                        [-(config.pointerWidth / 2), 0],
                        [0, config.pointerTailLength],
                        [config.pointerWidth / 2, 0],
                    ];
                    var pointerLine = d3.svg.line().interpolate("monotone");
                    var pg = svg
                        .append("g")
                        .data([lineData])
                        .attr("class", "pointer")
                        .attr("transform", centerTx);

                    pointer = pg
                        .append("path")
                        .attr(
                            "d",
                            pointerLine /*function(d) { return pointerLine(d) +'Z';}*/
                        )
                        .attr("transform", "rotate(" + config.minAngle + ")");

                    update(newValue === undefined ? 0 : newValue);
                }
                that.render = render;

                var numberFormat = d3.format(".1s");

                function update(newValue, newConfiguration) {
                    var label = window.data[1];
                    d3.select("#x")
                        .html(numberFormat(newValue) + "<br>" + label)
                        .style("margin-top", "-" + ((gaugeSize / 2 + 7) + "px"));
                    if (newConfiguration !== undefined) {
                        configure(newConfiguration);
                    }
                    var ratio = scale(newValue);
                    var newAngle = config.minAngle + ratio * range;
                    pointer
                        .transition()
                        .duration(config.transitionMs)
                        .ease("elastic")
                        .attr("transform", "rotate(" + newAngle + ")");
                }
                that.update = update;

                configure(configuration);

                return that;
            };

            function drawChart(data, plottingConfiguration = {}) {
                window.data = data;
                const [maxValue, yellowValue, redValue, readingValue] = data[0];

                gaugeSize = Math.min(window.innerWidth, window.innerHeight);
                if (gaugeSize > 600) {
                    gaugeSize = 600;
                }
                var powerGauge = gauge("#my_dataviz", {
                    size: gaugeSize,
                    clipWidth: gaugeSize,
                    clipHeight: gaugeSize,
                    ringWidth: gaugeSize / 6,
                    maxValue,
                    yellowValue,
                    redValue,
                    transitionMs: 1000,
                });
                powerGauge.render();

                function updateReadings(value) {
                    // just pump in random data here...
                    powerGauge.update(value);
                }

                // every few seconds update reading values
                updateReadings(readingValue);
            }

            // var data = [[50044, 12000, 1000, 2000], ["Label"]];
            // drawChart(data);
        </script>
    </body>
</html>
