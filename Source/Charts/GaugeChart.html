<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=320" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <title>Gauge Chart</title>

        <script src="./Data/d3DefaultConfig.js"></script>
        <script type="text/javascript" src="./Data/d3.v3.min.js"></script>
        <style>
            body {
                font-family: Helvetica, Arial, sans-serif;
                margin: 32px;
                text-align: center;
            }

            #power-gauge g.arc {
                fill: steelblue;
            }

            #power-gauge g.pointer {
                fill: #e85116;
                stroke: #b64011;
            }

            #power-gauge g.label text {
                text-anchor: middle;
                font-size: 14px;
                font-weight: bold;
                fill: #666;
            }
        </style>
    </head>
    <body>
        <div id="power-gauge"></div>
        <div style="text-center" id="x"></div>

        <script>
            var gauge = function (container, configuration) {
                var that = {};
                var config = {
                    size: 1000,
                    clipWidth: 500,
                    clipHeight: 400,
                    ringInset: 20,
                    ringWidth: 20,

                    pointerWidth: 10,
                    pointerTailLength: 5,
                    pointerHeadLengthPercent: 0.9,

                    minValue: 0,
                    maxValue: 8,

                    minAngle: -90,
                    maxAngle: 90,

                    transitionMs: 750,

                    majorTicks: 3,
                    labelFormat: d3.format(",g"),
                    labelInset: 10,

                    arcColorFn: d3.interpolateHsl(
                        d3.rgb("#b3de69"),
                        d3.rgb("#fccde5")
                    ),
                };
                var range = undefined;
                var r = undefined;
                var pointerHeadLength = undefined;
                var value = 0;

                var svg = undefined;
                var arc = undefined;
                var scale = undefined;
                var ticks = undefined;
                var tickData = undefined;
                var pointer = undefined;

                var donut = d3.layout.pie();

                function deg2rad(deg) {
                    return (deg * Math.PI) / 180;
                }

                function newAngle(d) {
                    var ratio = scale(d);
                    var newAngle = config.minAngle + ratio * range;
                    return newAngle;
                }

                function configure(configuration) {
                    var prop = undefined;
                    for (prop in configuration) {
                        config[prop] = configuration[prop];
                    }

                    range = config.maxAngle - config.minAngle;
                    r = config.size / 2;
                    pointerHeadLength = Math.round(
                        r * config.pointerHeadLengthPercent
                    );

                    // a linear scale that maps domain values to a percent from 0..1
                    scale = d3.scale
                        .linear()
                        .range([0, 1])
                        .domain([config.minValue, config.maxValue]);

                    ticks = scale.ticks(config.majorTicks);

                    const { maxValue, redValue, yellowValue } = config;

                    var redValueData = redValue / maxValue;

                    tickData = [
                        redValue / maxValue,
                        (yellowValue - redValue) / maxValue,
                        (maxValue - yellowValue) / maxValue,
                    ];
                    var covered = 0;

                    arc = d3.svg
                        .arc()
                        .innerRadius(r - config.ringWidth - config.ringInset)
                        .outerRadius(r - config.ringInset)
                        .startAngle(function (d, i) {
                            var ratio = covered;
                            covered += d;
                            return deg2rad(config.minAngle + ratio * range);
                        })
                        .endAngle(function (d, i) {
                            return deg2rad(config.minAngle + covered * range);
                        });
                }
                that.configure = configure;

                function centerTranslation() {
                    return "translate(" + r + "," + r + ")";
                }

                function isRendered() {
                    return svg !== undefined;
                }
                that.isRendered = isRendered;

                function render(newValue) {
                    svg = d3
                        .select(container)
                        .append("svg:svg")
                        .attr("class", "gauge")
                        .attr("width", config.clipWidth)
                        .attr("height", config.clipHeight);

                    var centerTx = centerTranslation();

                    var arcs = svg
                        .append("g")
                        .attr("class", "arc")
                        .attr("transform", centerTx);

                    arcs.selectAll("path")
                        .data(tickData)
                        .enter()
                        .append("path")
                        .attr("fill", function (d, i) {
                            switch (i) {
                                case 0:
                                    return constants.redColor;
                                case 1:
                                    return constants.yellowColor;
                                case 2:
                                    return constants.greenColor;
                            }
                        })
                        .attr("d", arc);

                    var lg = svg
                        .append("g")
                        .attr("class", "label")
                        .attr("transform", centerTx);
                    lg.selectAll("text")
                        .data(ticks)
                        .enter()
                        .append("text")
                        .attr("transform", function (d) {
                            var ratio = scale(d);
                            var newAngle = config.minAngle + ratio * range;
                            return (
                                "rotate(" +
                                newAngle +
                                ") translate(0," +
                                (config.labelInset - r) +
                                ")"
                            );
                        })
                        .text(config.labelFormat);

                    var lineData = [
                        [config.pointerWidth / 2, 0],
                        [0, -pointerHeadLength],
                        [-(config.pointerWidth / 2), 0],
                        [0, config.pointerTailLength],
                        [config.pointerWidth / 2, 0],
                    ];
                    var pointerLine = d3.svg.line().interpolate("monotone");
                    var pg = svg
                        .append("g")
                        .data([lineData])
                        .attr("class", "pointer")
                        .attr("transform", centerTx);

                    pointer = pg
                        .append("path")
                        .attr(
                            "d",
                            pointerLine /*function(d) { return pointerLine(d) +'Z';}*/
                        )
                        .attr("transform", "rotate(" + config.minAngle + ")");

                    update(newValue === undefined ? 0 : newValue);
                }
                that.render = render;

                function update(newValue, newConfiguration) {
                    d3.select("#x")
                        .text(newValue.toFixed(3))
                        .style("margin-top", "-280px");
                    if (newConfiguration !== undefined) {
                        configure(newConfiguration);
                    }
                    var ratio = scale(newValue);
                    var newAngle = config.minAngle + ratio * range;
                    pointer
                        .transition()
                        .duration(config.transitionMs)
                        .ease("elastic")
                        .attr("transform", "rotate(" + newAngle + ")");
                }
                that.update = update;

                configure(configuration);

                return that;
            };

            function drawChart(data, plottingConfiguration = {}) {
                const [maxValue, redValue, yellowValue, readingValue] = data[0];
                var powerGauge = gauge("#power-gauge", {
                    size: 600,
                    clipWidth: 600,
                    clipHeight: 600,
                    ringWidth: 100,
                    maxValue,
                    yellowValue,
                    redValue,
                    transitionMs: 3000,
                });
                powerGauge.render();

                function updateReadings(value) {
                    // just pump in random data here...
                    powerGauge.update(value);
                }

                // every few seconds update reading values
                updateReadings(readingValue);
            }

            const data = [[100, 50, 75, 43], ["Labels"]];
            drawChart(data);
        </script>
    </body>
</html>
