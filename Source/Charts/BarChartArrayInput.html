<html>
    <head>
        <script src="./Data/d3DefaultConfig.js"></script>
        <script src="./Data/utils.js"></script>
        <script src="./Data/d3.v4.min.js"></script>
        <script src="./Data/d3-scale-chromatic.v1.min.js"></script>
        <link rel="stylesheet" href="Data/general.css" />
    </head>

    <body>
        <!-- html containers starts-->
        <div id="mainChartWindow" style="display: flex">
            <div id="yAxisDiv"></div>
            <div id="my_dataviz"></div>
            <div id="xAxisLabelId"></div>
        </div>

        <div id="tooltip"></div>

        <div id="legend"></div>
        <!-- html containers ends-->
        <!-- javascripts starts -->
        <script>
            // variables
            var extraHeightWorked = false;
            var redrawn = false;
            var extraHeight = 0;

            var data = dataConstant.dataBarChart;

            //  draw function defination starts
            function drawChart(data, plottingConfiguration = {}) {
                if (!redrawn) {
                    extraHeight = 0;
                }
                window.data = data;
                dataValues = data[0];

                // data values to be plot
                var dataValues = data[0];

                // Plot configuration contains all the config of report, these values are passed from QML,
                // if no value is passed default value is taken from defaultConfig.js

                // plottingConfiguration variables
                let {
                    d3colorPalette,
                    paddingInner,
                    markerShape,
                    curveType,
                    dateFormat,
                    chartType,
                    toolTip,
                    dataColumns,
                    legendConfig = defaultD3Config.defaultLegendConfig,
                    labelConfig = defaultD3Config.defaultlabelConfig,
                    gridConfig = defaultD3Config.defaultGridConfig,
                    standardThresholdWidth,
                    // font size
                    xLabelfontSize = defaultD3Config.fontSize,
                    yLabelfontSize = defaultD3Config.fontSize,
                    xTickfontSize = defaultD3Config.fontSize,
                    yTickfontSize = defaultD3Config.fontSize,
                    dataLabelfontSize = defaultD3Config.fontSize,
                    // font family
                    xLabelfontFamily = defaultD3Config.fontFamily,
                    yLabelfontFamily = defaultD3Config.fontFamily,
                    xTickfontFamily = defaultD3Config.fontFamily,
                    yTickfontFamily = defaultD3Config.fontFamily,
                    dataLabelfontFamily = defaultD3Config.fontFamily,
                    // font color
                    xLabelfontColor = defaultD3Config.fontColor,
                    yLabelfontColor = defaultD3Config.fontColor,
                    xTickfontColor = defaultD3Config.fontColor,
                    yTickfontColor = defaultD3Config.fontColor,
                    dataLabelColor = defaultD3Config.fontColor,
                    // xaxis setting
                    xAxisConfig = defaultD3Config.xAxisConfig,
                    yAxisConfig = defaultD3Config.yAxisConfig
                } = plottingConfiguration;

                // plottingConfiguration restore from windows
                window.xLabelfontSize = xLabelfontSize;
                window.yLabelfontSize = yLabelfontSize;
                window.xTickfontSize = xTickfontSize;
                window.yTickfontSize = yTickfontSize;
                window.dataLabelfontSize = dataLabelfontSize;

                window.xLabelfontFamily = xLabelfontFamily;
                window.yLabelfontFamily = yLabelfontFamily;
                window.xTickfontFamily = xTickfontFamily;
                window.yTickfontFamily = yTickfontFamily;
                window.dataLabelfontFamily = dataLabelfontFamily;

                window.xLabelfontColor = xLabelfontColor;
                window.yLabelfontColor = yLabelfontColor;
                window.xTickfontColor = xTickfontColor;
                window.yTickfontColor = yTickfontColor;
                window.dataLabelColor = dataLabelColor;

                d3.selectAll("#my_dataviz").html("");
                d3.selectAll("#yAxisDiv").html("");
                d3.selectAll("#xAxisLabelId").html("");

                let { legendStatus, legendPosition } = legendConfig;
                let { labelStatus, labelFormat } = labelConfig;
                let { xAxisColumnDetails = [], colorByData = [] } = dataColumns;
                let { xlabel, xboldLabel, xitalicLabel, xboldTick, xitalicTick, xaxisStatus } = xAxisConfig;
                let { ylabel, yboldLabel, yitalicLabel, yboldTick, yitalicTick, yaxisStatus } = yAxisConfig;
                window.yboldLabel = yboldLabel;
                window.xboldLabel = xboldLabel;
                window.xitalicLabel = xitalicLabel;
                window.yitalicLabel = yitalicLabel;
                let { gridStatus } = gridConfig;

                if (!d3colorPalette) {
                    d3colorPalette = defaultD3Config.d3ColorPalette;
                }
                if (!xAxisConfig.xlabel && !yAxisConfig.ylabel) {
                    [xAxisLabel, yAxisLabel] = data[1];
                } else {
                    [xAxisLabel, yAxisLabel] = [xAxisConfig.xlabel, yAxisConfig.ylabel];
                }

                d3Colors = d3colorPalette;

                // legends code starts
                d3.select("#legend").html("").style("padding", "");

                // legends code ends
                if (!paddingInner) {
                    paddingInner = defaultD3Config.defaultPaddingInner;
                }

                if (!dateFormat) {
                    dateFormat = defaultD3Config.dateFormat;
                }

                if (!chartType) {
                    chartType = defaultD3Config.chartType;
                }

                if (!standardThresholdWidth) {
                    standardThresholdWidth = defaultD3Config.standardThresholdWidth;
                }

                if (!toolTip || !Object.keys(toolTip).length ) {
                    toolTip = {
                        textColumn1: xAxisLabel,
                        textColumn2: yAxisLabel
                    };
                }

                const { top, right, bottom, left } = constants.chartMargins;
                var margin = {
                    top,
                    right,
                    bottom,
                    left
                };
                var width = window.innerWidth - 100;

                var xAxisDataSet = dataValues[0];

                var xAxisDateWiseValues = {};

                var y_pos_x_label = 55;

                var valueDateType = false;
                if (xAxisColumnDetails[0].itemType == "Date") {
                    valueDateType = true;
                    dateFormat = xAxisColumnDetails[0].dateFormat;
                }

                if (valueDateType && !redrawn) {
                    xAxisDataSet.forEach((d, i) => {
                        var requiredTypeData = getDateFormattedData(d, dateFormat);

                        if (!xAxisDateWiseValues[requiredTypeData]) {
                            xAxisDateWiseValues[requiredTypeData] = 0;
                        }

                        // console.log(requiredTypeData, redrawn);
                        xAxisDateWiseValues[requiredTypeData] += dataValues[1][i];
                    });

                    var sortedKeys = sortDates(xAxisDateWiseValues, dateFormat);

                    dataValues[0] = sortedKeys;
                    dataValues[1] = sortedKeys.map((d, i) => xAxisDateWiseValues[d]);
                    data[0] = dataValues;
                }

                if (chartType == constants.chartType.STANDARD) {
                    width = dataValues[0].length * standardThresholdWidth;
                }

                var height = window.innerHeight - margin.top - margin.bottom - extraHeight - 20;

                // legends height ,width elements

                const yAxisWidth = document.querySelector("#yAxisDiv").clientWidth;

                d3.select("#legend").attr("style", null);
                d3.select("#mainChartWindow").attr("style", null);
                d3.select("#xAxisLabelId").style("bottom", 20 + "px");

                // legends code starts
                var legendElement = document.querySelector("#legend");
                var legendHeight = legendElement.offsetHeight;
                var legendWidth = legendElement.offsetWidth;

                legendGenerate(legendStatus, legendPosition, yAxisWidth, width, margin, height);

                if (legendPosition == "left" || legendPosition == "right") {
                    var legendWidth = legendElement.offsetWidth;
                    width -= legendWidth;
                }
                if (legendPosition == "top") {
                    var legendHeightTop = legendHeight;
                } else {
                    legendHeightTop = 0;
                }
                if (legendPosition == "left") {
                    var legendWidthLeft = legendWidth;
                } else {
                    legendWidthLeft = 0;
                }

                // legends code ends
                var mainChartWidth = document.querySelector("#mainChartWindow").clientWidth;
                // console.log({ legendWidth, width, mainChartWidth });

                //add svg with margin !important
                //this is svg is actually group
                var svg = d3
                    .selectAll("#my_dataviz")
                    .append("svg")
                    .attr("width", width+10)
                    .attr("height", height + extraHeight + margin.top + margin.bottom)
                    .append("g") //add group to leave margin for axis
                    .attr("transform", "translate(0," + margin.top + ")");

                var dataset = dataValues[1];

                var maxHeight = d3.max(dataset, function (d) {
                    return Math.abs(d);
                });
                var minHeight = d3.min(dataset, function (d) {
                    return d;
                });

                if (minHeight > 0) {
                    minHeight = 0;
                }

                // height = height - 100;
                //set y scale
                var yScale = d3.scaleLinear().rangeRound([0, height]).domain([maxHeight, minHeight]).nice();
                //show negative

                yaxisTicks = height / 70;

                //add x and y axis
                var yAxis = d3.axisLeft(yScale).tickSize(0).ticks(yaxisTicks).tickFormat(d3.format(".2s"));
                var xAxisLabelSvg=d3.select("#xAxisLabelId").append("svg").attr("width", window.innerWidth).attr("height", 40);

                d3.select("#yAxisDiv")
                    .append("svg")
                    .attr("width", "72")
                    .attr("height", height + margin.top + margin.bottom)
                    .style("margin-top", margin.top - 5)
                    .append("g") //add group to leave margin for axis
                    .attr("transform", "translate(" + margin.left + ",5)")
                    .append("g")
                    .attr("class", "y-axis")
                    .call(yAxis);

                if (gridStatus) {
                    svg.append("g")
                        .attr("class", "grid")
                        .style("stroke-width", "1")
                        .call(make_y_gridlines(yScale).tickSize(-width).tickFormat(d3.format(".2s")));
                } else {
                    svg.append("g")
                        .attr("class", "grid")
                        .style("stroke-width", "1")
                        .call(
                            make_y_gridlines(yScale)
                                // .tickSize(-width)
                                .tickFormat(d3.format(".2s"))
                        );
                }

                d3.selectAll("#yAxisDiv text")
                    .attr("font-size", yTickfontSize)
                    .attr("font-family", yTickfontFamily)
                    .attr("fill", yTickfontColor);

                //add x axis
                var xScale = d3
                    .scaleBand()
                    .domain(dataValues[0])
                    .range([0, width])
                    .padding(paddingInner)
                    .paddingInner(paddingInner);

                //scaleBand is used for  bar chart

                /*if domain is specified, sets the domain to the specified array of values.
    The first element in domain will be mapped to the first band, the second domain value to the second band, and so on.
    Domain values are stored internally in a map from stringified value to index; the resulting index is then used to determine the band.
    Thus, a band scale’s values must be coercible to a string, and the stringified version of the domain value uniquely identifies the corresponding band.
    If domain is not specified, this method returns the current domain.*/

                var barpadding = 10;
                var bars = svg
                    .selectAll("rect")
                    .data(dataset)
                    .enter()
                    .append("rect")
                    .attr("class", "bar")
                    .attr("x", function (d, i) {
                        this.setAttribute("data-value-x", dataValues[0][i]);
                        this.setAttribute("data-value-y", dataValues[1][i]);
                        return xScale(dataValues[0][i]); //i*(width/dataset.length);
                    })
                    .attr("y", function (d) {
                        let yValue = null;
                        if (d < 0) {
                            yValue = yScale(0);
                        } else {
                            yValue = yScale(d);
                        }
                        return yValue;
                    }) //for bottom to top
                    .attr("width", xScale.bandwidth() /*width/dataset.length-barpadding*/)
                    .attr("height", function (d) {
                        var height = Math.abs(yScale(0) - yScale(Math.abs(d)));
                        if (!height) {
                            height = 1;
                        }
                        return height;
                    })
                    .attr("fill", d3Colors[0])
                    .on("mouseout", function (d, i) {
                        d3.select("#tooltip").style("display", "none");
                        d3.selectAll(".bar").style("opacity", 1);
                    })
                    .on("mouseover mousemove", function (d, i) {
                        let xpos = d3.mouse(this)[0] + margin.left;
                        let ypos = d3.mouse(this)[1];

                        let xValue = this.getAttribute("data-value-x");
                        let yValue = this.getAttribute("data-value-y");

                        // tooltip Ui fix

                        tooltipGenerate(xpos, ypos, xValue, yValue, legendHeightTop, d, toolTip, legendWidthLeft);

                        d3.selectAll(".bar").style("opacity", 0.3);
                        d3.select(this).style("opacity", 1);
                    });

                var xAxis = d3.axisBottom(xScale);
                svg.append("g")
                    .call(xAxis.tickSize(0))
                    .attr("class", "x-axis axis")
                    .attr("transform", "translate(0," + height + ")");

                setLabel(
                    xAxisLabel,
                    "x_label",
                    xAxisLabelSvg,
                    y_pos_x_label,
                    false
                );

                setLabel(yAxisLabel, "y_label", d3.select("svg"), false);

                setYaxisWidth(margin);

                var barWidth = document.querySelector(".bar") && document.querySelector(".bar").getBBox().width;
                if (chartType == constants.chartType.FIT_WIDTH && barWidth < 40) {
                    setXaxisWidth();
                } else {
                    setStandardTickWidths(barWidth);
                }

                // Remove Text in case they are large in number
                var allXAxisTexts = document.querySelectorAll(".x-axis text");
                var textWidth =
                    document.querySelector(".x-axis .tick text") &&
                    document.querySelector(".x-axis .tick text").getBBox().height;

                if (chartType == constants.chartType.FIT_WIDTH) {
                    for (var i = 0; i < allXAxisTexts.length; i++) {
                        if (!Math.floor(data[0][0].length * 0.02)) {
                            break;
                        }

                        if (i % Math.floor(data[0][0].length * 0.04) != 0) {
                            allXAxisTexts[i].remove();
                            continue;
                        }
                    }
                }
                if (labelStatus) {
                    console.log("FrontEnd-Debug:Label Status is on");
                    dataLabel(svg, xAxis, yScale, dataset, labelFormat);
                }

                if (chartType === constants.chartType.FIT_WIDTH) {
                    var allXAxisTexts = document.querySelectorAll(".x-axis text");
                    for (var i = 0; i < allXAxisTexts.length; i++) {
                        var xAxisTick = allXAxisTexts[i].innerHTML;
                        // Check added to bypass all the names with length <= 2 from getting trimmed
                        if (xAxisTick && xAxisTick.length <= 2) {
                            continue;
                        }
                        if (xAxisTick) {
                            var singleCharacterLength =
                                allXAxisTexts[i].getBBox().width / (xAxisTick && xAxisTick.length);

                            var numOfCharacters =
                                (extraHeight ? extraHeight : xScale.bandwidth()) / singleCharacterLength;

                            if (xAxisTick && xAxisTick.length > numOfCharacters) {
                                if (Math.ceil(numOfCharacters) > 3) {
                                    // console.log(xAxisTick);
                                    allXAxisTexts[i].innerHTML =
                                        (xAxisTick && xAxisTick.substr(0, numOfCharacters - 3)) + "...";
                                } else {
                                    allXAxisTexts[i].innerHTML = (xAxisTick && xAxisTick.substr(0, 2)) + "...";
                                }
                            }
                        }

                        if (i == 0 && barWidth < textWidth * 0.5) {
                            allXAxisTexts[i].setAttribute("dy", "1em");
                            continue;
                        }
                        if (barWidth < textWidth * 0.5) {
                            allXAxisTexts[i].setAttribute("dy", "0.8em");
                        }
                    }
                }

                if (extraHeightWorked && !redrawn) {
                    extraHeightWorked = false;
                    redrawn = true;
                    drawChart(window.data, plottingConfiguration);
                }

                if (extraHeightWorked && redrawn) {
                    extraHeightWorked = false;
                    redrawn = false;
                }

                YAxisTicksConfig(yTickfontSize, yTickfontFamily, yboldTick, yitalicTick, yTickfontColor);
                XAxisTicksConfig(xTickfontSize, xTickfontFamily, xboldTick, xitalicTick, xTickfontColor);

                if (xaxisStatus) {
                    d3.selectAll("g .x-axis").attr("style", "display: block");
                } else {
                    d3.selectAll("g .x-axis").attr("style", "display: none");
                }
                if (yaxisStatus) {
                    d3.selectAll("g .y-axis").attr("style", "display: block");
                } else {
                    d3.selectAll("g .y-axis").attr("style", "display: none");
                }

                removeDataLabels();
            }
            //  draw function defination starts

            // redraw chart
            // redrawChartBarVerticle();

            drawChartBarVerticle();
        </script>
        <!-- javascripts ends -->
    </body>
</html>
