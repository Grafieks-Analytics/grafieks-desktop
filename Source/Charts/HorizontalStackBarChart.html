<!DOCTYPE html>
<meta charset="utf-8" />
<head>
    <script src="./Data/d3DefaultConfig.js"></script>
    <script src="./Data/utils.js"></script>
    <script src="./Data/d3.v4.min.js"></script>
    <script src="./Data/d3-scale-chromatic.v1.min.js"></script>
    <link rel="stylesheet" href="Data/general.css" />
    <style>
        .y-axis .domain {
            display: none;
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div style="display: flex; flex-direction: column">
        <div id="my_dataviz"></div>
        <div id="xAxisDiv"></div>
    </div>

    <script>
        // reference: https://bl.ocks.org/seasmith/b72e6b8be1978eae046e0cff131668b1
        var data = [
            [
                ["2018-08-05", "2018-08-05", "139.81"],
                ["2018-08-05", "2019-02-05", "100.81"],
                ["2018-08-05", "2019-08-05", "136.35"],
                ["2018-08-05", "2019-02-05", "143.22"],
                ["2012-08-05", "2019-08-05", "0"],
                ["2013-08-05", "2018-08-05", "241.64"],
                ["2014-08-05", "2019-08-05", "48.43"],
                ["2012-08-05", "2019-02-05", "54.43"],
                ["2012-08-05", "2019-08-05", "154.43"],
                ["2011-08-05", "2018-08-05", "-211.31"],
                ["2013-08-05", "2019-08-05", "-200.36"],
                ["2013-08-05", "2019-08-05", "0"],
                ["2019-08-05", "2019-08-05", "321.31"],
                ["2019-08-05", "2013-08-05", "500.36"],
                ["2019-08-05", "2019-08-05", "103.7"],
                ["2019-08-05", "2019-08-05", "100.82"],
            ],
            [
                "2018-08-05",
                "2019-08-05",
                "2019-08-05",
                "2019-08-05",
                "2019-02-05",
            ],
            ["2019", "2018"],
        ];

        function transformData(dataValue, dateFormat, dateFormat1) {
            json = {};
            var isKey1Date = false;
            var isKey2Date = false;

            if (isDateFormat(dataValue[0][1])) {
                isKey1Date = true;
            }
            if (isDateFormat(dataValue[0][0])) {
                isKey2Date = true;
            }

            var uniqueKey2 = [];
            var uniqueKey = [];
            dataValue.forEach((d) => {
                if (isKey1Date) {
                    var key = getDateFormattedData(d[1], dateFormat);
                } else {
                    var key = d[1];
                }

                if (!json[key]) {
                    json[key] = {};
                }
                if (isKey2Date) {
                    var key2 = getDateFormattedData(d[0], dateFormat1);
                } else {
                    var key2 = d[0];
                }
                if (!uniqueKey2.includes(key2)) {
                    uniqueKey2.push(key2);
                }
                if (!uniqueKey.includes(key)) {
                    uniqueKey.push(key);
                }

                var value = d[2];

                if (!json[key][key2]) {
                    json[key][key2] = 0;
                }

                json[key][key2] += +value;
            });

            var response = [];
            var allKeys = uniqueKey2;

            for (var key in json) {
                if (Object.keys(json[key]).length < allKeys.length) {
                    allKeys.forEach((d) => {
                        if (!json[key][d]) {
                            json[key][d] = 0;
                        }
                    });
                }
                response.push({ ...json[key], key });
            }

            const yAxisUniqueKeys = uniqueKey;
            return [response, allKeys, yAxisUniqueKeys, data[2]];
        }

        drawChart(data);

        function drawChart(data, plottingConfiguration = {}) {
            window.data = data;

            var keys = data[1];

            let {
                d3colorPalette,
                paddingInner,
                markerShape,
                curveType,
                dateFormat,
                dateFormat1,
                chartType,
                standardThresholdHeight,
            } = plottingConfiguration;

            if (!d3colorPalette) {
                d3colorPalette = defaultD3Config.d3ColorPalette;
            }
            d3Colors = d3colorPalette;

            if (!paddingInner) {
                paddingInner = defaultD3Config.defaultPaddingInner;
            }

            if (!dateFormat) {
                dateFormat = defaultD3Config.dateFormat;
            }

            if (!dateFormat1) {
                dateFormat1 = defaultD3Config.dateFormat;
            }

            if (!chartType) {
                chartType = defaultD3Config.horizontalChartType;
            }

            if (!standardThresholdHeight) {
                standardThresholdHeight =
                    defaultD3Config.standardThresholdHeight;
            }

            var [data, keys, yAxisUniqueKeys, labels] = transformData(
                data[0],
                dateFormat,
                dateFormat1
            );

            var margin = { top: 20, right: 20, bottom: 30, left: 40 };
            var width = window.innerWidth - margin.left - margin.right - 50;
            var height = window.innerHeight - margin.top - margin.bottom - 50;

            if (chartType == constants.chartType.STANDARD) {
                height = yAxisUniqueKeys.length * standardThresholdHeight;
                if (height + margin.top + margin.bottom < window.innerHeight) {
                    d3.select("#xAxisDiv").style(
                        "top",
                        height + margin.top + "px"
                    );
                } else {
                    d3.select("#xAxisDiv").style("bottom", "0");
                    d3.select("#xAxisDiv").style("top", null);
                }
            } else {
                d3.select("#xAxisDiv").style("bottom", "0");
            }

            var timeFormat = d3.timeFormat("%m-%Y");
            var parseDate = d3.timeParse("%Y");

            var y = d3
                .scaleBand()
                .domain(
                    data.map(function (d) {
                        return d.key;
                    })
                )
                .rangeRound([margin.top, height - margin.bottom])
                .padding(paddingInner)
                .paddingInner(paddingInner);

            var barWidth = y.bandwidth();

            var series = d3.stack().keys(keys).offset(d3.stackOffsetDiverging)(
                data
            );

            var x = d3
                .scaleLinear()
                .domain([d3.min(series, stackMin), d3.max(series, stackMax)])
                .rangeRound([0, width - margin.right])
                .nice();

            var z = d3.scaleOrdinal(d3Colors);

            clearChart();
            var svg = d3
                .selectAll("#my_dataviz")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr(
                    "transform",
                    "translate(" + margin.left + "," + (margin.top + 10) + ")"
                );

            svg.append("g")
                .attr("class", "grid")
                .style("stroke-width", "1")
                .call(make_x_gridlines(x).tickSize(height).tickFormat(""));

            var keysIterator = 0;
            svg.append("g")
                .selectAll("g")
                .data(series)
                .enter()
                .append("g")
                .attr("fill", function (d) {
                    return z(d.key);
                })
                .selectAll("rect")
                .data(function (d, i) {
                    return d;
                })
                .enter()
                .append("rect")
                .attr("height", y.bandwidth)
                .attr("class", "bar")
                .attr("y", function (d) {
                    return y(d.data.key);
                })
                .attr("x", function (d, i) {
                    return x(d[0]);
                })
                .attr("width", function (d) {
                    return x(d[1]) - x(d[0]);
                })
                .on("mouseout", function (d, i) {
                    d3.select("#tooltip").style("display", "none");
                    d3.selectAll(".bar").style("opacity", 1);
                })
                .on("mouseover mousemove", function (d, i) {
                    let xpos1 = d3.mouse(this)[0] + margin.left;
                    let ypos = d3.mouse(this)[1] - 20;

                    d3.select("#tooltip")
                        .style("left", xpos1 + "px")
                        .style("top", ypos + "px")
                        .style("display", "block")
                        .style("position", "absolute")
                        .text(function () {
                            var textValue = d[1] - d[0];
                            var labelName = d.data.key;
                            return textValue.toFixed(3);
                        });

                    d3.selectAll(".bar").style("opacity", 0.3);
                    d3.select(this).style("opacity", 1);
                });

            svg.append("g")
                .attr("transform", "translate(0, 0)")
                .attr("class", "y-axis")
                .call(d3.axisLeft(y).tickSize(0));

            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(x).tickSize(0));

            var xAxis = d3.axisBottom(x).tickSize(0).ticks(10);

            d3.select("#xAxisDiv")
                .append("svg")
                .attr("height", "72")
                .attr("width", width + margin.left + margin.right)
                .append("g") //add group to leave margin for axis
                .attr(
                    "transform",
                    "translate(" + margin.left + ",0)"
                    // "translate(0,0)"
                )
                .append("g")
                .attr("class", "x-axis")
                .call(xAxis);

            function stackMin(series) {
                return d3.min(series, function (d) {
                    return d[0];
                });
            }

            function stackMax(series) {
                return d3.max(series, function (d) {
                    return d[1];
                });
            }

            function make_x_gridlines(x) {
                return d3.axisBottom(x);
            }
            function make_y_gridlines(y) {
                return d3.axisLeft(y).ticks(10);
            }
        }
    </script>
</body>
