<!DOCTYPE html>
<html>
    <head>
        <script src="./Data/d3DefaultConfig.js"></script>
        <script src="./Data/utils.js"></script>
        <script src="./Data/d3.v4.min.js"></script>
        <script src="./Data/d3-scale-chromatic.v1.min.js"></script>
        <link rel="stylesheet" href="Data/general.css" />
        <style type="text/css">
            body {
                padding: 0;
                margin: 0;
            }
        </style>
        <style>
            .axis .domain {
                display: none;
            }
        </style>
        <style type="text/css">
            body {
                padding: 0;
                margin: 0;
                overflow-y: hidden;
                /* overflow-x: hidden; */
            }
            #yAxisDiv {
                position: fixed;
                background: #fff;
            }
        </style>
    </head>

    <body>
        <div style="display: flex">
            <div id="yAxisDiv"></div>
            <div id="my_dataviz"></div>
        </div>
        <div id="tooltip"></div>
        <script>
            function sumAllData(originalData, currentData) {
                console.log({ originalData });
                var allKeys = [
                    ...Object.keys(originalData),
                    ...Object.keys(currentData),
                ];

                allKeys = allKeys.filter((d) => {
                    if (d != "mainCategory") {
                        return d;
                    }
                });

                allKeys.forEach((d) => {
                    console.log(originalData[d], currentData[d]);
                    originalData[d] =
                        (originalData[d] || 0) + (currentData[d] || 0);
                });

                console.log(originalData);

                // debugger;

                return originalData;
            }

            function transformData(dataValue, dateFormat) {
                var transformedDataValue = {};
                var globalKeys = [];

                dataValue[0].forEach((d, i) => {
                    var currentData = d;

                    var category = getDateFormattedData(
                        d.mainCategory,
                        dateFormat
                    );
                    console.log(category);
                    if (!transformedDataValue[category]) {
                        transformedDataValue[category] = {};
                    }
                    var originalData = transformedDataValue[category];

                    var allKeys = [
                        ...Object.keys(originalData),
                        ...Object.keys(currentData),
                    ];

                    allKeys = allKeys
                        .filter((d) => {
                            if (d != "mainCategory") {
                                return d;
                            }
                        })
                        .filter(getUniqueArrayValues);

                    globalKeys.push(...allKeys);

                    allKeys.forEach((d) => {
                        console.log(originalData[d], currentData[d]);
                        originalData[d] =
                            (originalData[d] || 0) + (currentData[d] || 0);
                    });
                    transformedDataValue[category] = {
                        ...originalData,
                        mainCategory: category,
                    };

                    console.log({ transformedDataValue });
                });

                var transformedDataValue = Object.keys(
                    transformedDataValue
                ).map((d) => transformedDataValue[d]);

                globalKeys = globalKeys.filter(getUniqueArrayValues);
                return [transformedDataValue, globalKeys];
            }

            function drawChart(data, plottingConfiguration = {}) {
                window.data = data;

                let {
                    d3colorPalette,
                    paddingInner,
                    markerShape,
                    curveType,
                    dateFormat,
                    chartType,
                    standardThresholdWidth,
                    subCategoryColour,
                    categoryColor,
                } = plottingConfiguration;

                if (!d3colorPalette) {
                    d3colorPalette = defaultD3Config.d3ColorPalette;
                }
                d3Colors = d3colorPalette;

                if (!paddingInner) {
                    paddingInner = defaultD3Config.defaultPaddingInner;
                }

                if (!dateFormat) {
                    dateFormat = defaultD3Config.dateFormat;
                }

                if (!chartType) {
                    chartType = defaultD3Config.chartType;
                }

                if (!standardThresholdWidth) {
                    standardThresholdWidth =
                        defaultD3Config.standardThresholdWidth;
                }

                data = transformData(data, dateFormat);

                var [data, all_keys] = data;

                var margin = { top: 40, right: 20, bottom: 0, left: 70 };
                var width = window.innerWidth - margin.left - margin.right - 70;

                if (chartType == constants.chartType.STANDARD) {
                    width = numberOfBars(data) * standardThresholdWidth;
                }

                function numberOfBars(data) {
                    var count = 0;
                    for (var i = 0; i < data.length; i++) {
                        var innerData = data[i];
                        count += Object.keys(innerData).length - 1;
                    }
                    return count;
                }

                var height = window.innerHeight - margin.top - margin.bottom;

                clearChart();

                var minHeight = d3.min(data, (d) =>
                    d3.min(all_keys, (k) => d[k])
                );

                if (minHeight > 0) {
                    minHeight = 0;
                }

                var maxHeight = d3.max(data, (d) =>
                    d3.max(all_keys, (k) => d[k])
                );

                //add svg with margin !important
                //this is svg is actually group
                var svg = d3
                    .selectAll("#my_dataviz")
                    .append("svg")
                    .attr("width", width + 100)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g") //add group to leave margin for axis
                    .attr(
                        "transform",
                        "translate(" + margin.left + "," + margin.top + ")"
                    );

                const xScale0 = d3
                    .scaleBand()
                    .range([0, width])
                    .padding(paddingInner);

                // var yScale = d3
                //     .scaleLinear()
                //     .rangeRound([0, height])
                //     .domain([maxHeight, minHeight])
                //     .nice();

                const yScale = d3
                    .scaleLinear()
                    .rangeRound([height - margin.top - margin.bottom, 0]);

                var zScale = d3.scaleOrdinal().range(d3Colors);

                // const xAxis = d3.axisBottom(xScale0);
                // const yAxis = d3.axisLeft(yScale);

                yaxisTicks = height / 70;

                yScale.domain([minHeight, maxHeight]).nice();

                //add x and y axis
                var yAxis = d3.axisLeft(yScale).tickSize(0).ticks(yaxisTicks);

                d3.select("#yAxisDiv")
                    .append("svg")
                    .attr("width", "72")
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g") //add group to leave margin for axis
                    .attr(
                        "transform",
                        "translate(" + margin.left + "," + margin.top + ")"
                    )
                    .append("g")
                    .attr("class", "y-axis")
                    .call(yAxis);

                xScale0.domain(data.map((d) => d.mainCategory));

                svg.append("g")
                    .attr("class", "grid")
                    .style("stroke-width", "1")
                    .call(
                        make_y_gridlines(yScale).tickSize(-width).tickFormat("")
                    );

                svg.selectAll(".groups")
                    .data(data)
                    .enter()
                    .append("g")
                    .attr("class", "mainCategory")
                    .each(function (group_data) {
                        const bar_data = getBars(group_data),
                            x_offset = groupOffset(group_data),
                            group_keys = bar_data.map((d) => d.name);
                        xScale1 = d3
                            .scaleBand()
                            .domain(group_keys)
                            .range([0, xScale0.bandwidth() - x_offset * 2])
                            .padding(paddingInner);

                        d3.select(this)
                            .attr(
                                "transform",
                                (d) =>
                                    `translate(${
                                        xScale0(d.mainCategory) + x_offset
                                    },0)`
                            )
                            .selectAll(".bar")
                            .data(bar_data)
                            .enter()
                            .append("rect")
                            .attr("class", "bar")
                            .attr("fill", function (d) {
                                if (categoryColor) {
                                    return zScale(d.data.mainCategory);
                                }
                                if (subCategoryColour) {
                                    return zScale(d.name);
                                }
                                return d3Colors[4];
                            })
                            .on("mouseout", function (d, i) {
                                d3.select("#tooltip").style("display", "none");
                                d3.selectAll(".bar").style("opacity", 1);
                            })
                            .on("mouseover mousemove", function (d, i) {
                                let xpos = d3.mouse(this)[0] - 20;
                                let ypos = d3.mouse(this)[1];
                                var parentElement = this.parentElement;

                                const matrix =
                                    window.getComputedStyle(
                                        parentElement
                                    ).transform;
                                const matrixValues = matrix
                                    .match(/matrix.*\((.+)\)/)[1]
                                    .split(", ");

                                xpos += +matrixValues[4] || 0;

                                d3.select("#tooltip")
                                    .style("left", xpos + "px")
                                    .style("top", ypos + "px")
                                    .style("display", "block")
                                    .html(d.name + ":" + d.value);

                                d3.selectAll(".bar").style("opacity", 0.3);
                                d3.select(this).style("opacity", 1);
                            })
                            .attr("x", (d) => xScale1(d.name))
                            .attr("y", (d) => {
                                if (d.value < 0) {
                                    return yScale(0);
                                }
                                return yScale(d.value);
                            })
                            .attr("width", xScale1.bandwidth())
                            .attr("height", (d) => {
                                var heightValue = Math.abs(
                                    yScale(0) - yScale(Math.abs(d.value))
                                );
                                if (!heightValue) {
                                    heightValue = 1;
                                }
                                return heightValue;

                                // return (
                                //     height -
                                //     margin.top -
                                //     margin.bottom -
                                //     yScale(d.value)
                                // );
                            });
                    });

                var xAxis = d3.axisBottom(xScale0);

                // Add the X Axis
                svg.append("g")
                    .attr("class", "x-axis")
                    .attr(
                        "transform",
                        `translate(0,${height - margin.top - margin.bottom})`
                    )
                    .call(xAxis);

                // Add the Y Axis
                // svg.append("g").attr("class", "y-axis").call(yAxis);

                function getBars(d) {
                    const bars = [];
                    all_keys.forEach((k) => {
                        if (d.hasOwnProperty(k)) {
                            bars.push({ name: k, value: d[k], data: d });
                        }
                    });
                    return bars;
                }

                function groupOffset(d) {
                    const groupElementsCount = all_keys.reduce(
                            (acc, k) =>
                                d.hasOwnProperty(k) ? (acc += 1) : acc,
                            0
                        ),
                        allElementsCount = all_keys.length,
                        groupWidth = xScale0.bandwidth(),
                        x_offset =
                            ((1 - groupElementsCount / allElementsCount) *
                                groupWidth) /
                            2;

                    return x_offset;
                }

                function make_x_gridlines(x) {
                    return d3.axisBottom(x).ticks(8);
                }
                function make_y_gridlines(y) {
                    return d3.axisLeft(y).ticks(yaxisTicks);
                }

                function getDateFormattedData(dateValue, dateFormat) {
                    return d3.timeFormat(dateFormat)(new Date(dateValue));
                }
            }

            var data = [
                {
                    mainCategory: "2018-02-01",
                    field1: 19,
                    field2: 83,
                    field3: 2,
                    field4: 30,
                },
                {
                    mainCategory: "2019-04-02",
                    field1: 100,
                    field2: 29,
                    field3: 100,
                    field4: 130,
                },
                {
                    mainCategory: "2019-03-03",
                    field1: 100,
                    field3: 100,
                },
                {
                    mainCategory: "2019-03-01",
                    field1: 100,
                    field2: 43,
                    field3: 100,
                },
                {
                    mainCategory: "2021-03-03",
                    field1: 98,
                    field2: 43,
                    field3: 100,
                },
                {
                    mainCategory: "2018-02-04",
                    field1: -98,
                    field2: 43,
                    field3: 100,
                },
                {
                    mainCategory: "2019-04-09",
                    field1: 100,
                    field2: 43,
                    field3: 10,
                },
                {
                    mainCategory: "2019-03-09",
                    field2: 43,
                    field3: 100,
                },
            ];

            var all_keys = ["field1", "field2", "field3", "field4"];

            data = [data, all_keys];
            drawChart(data);
        </script>
    </body>
</html>
